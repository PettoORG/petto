import 'dart:async';

import 'package:dartz/dartz.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'package:petto/core/domain/base_entity.dart';
import 'package:petto/core/domain/failure.dart';
import 'package:petto/core/form/application/base_entity_state.dart';
import 'package:petto/core/infrastructure/base_firestore_repository.dart';
import 'package:petto/core/infrastructure/log.dart';
import 'package:rxdart/rxdart.dart';

/// Mixin class to be used in a Riverpod Entity Notifier class. It provides
/// default methods to save, create, update and delete an Entity in the Database.
abstract mixin class EntityNotifierMixin<T extends BaseEntity> {
  /// Setter for the Entity Id.
  set id(String? id);

  /// Getter (boolean) with current internet connection status.
  bool? get internetConnection;

  /// Instance of Firestore Repository.
  BaseFirestoreRepository get repository;

  /// Instance of Firebase Crashlytics.
  FirebaseCrashlytics get crashlytics;

  /// Getter with the current state. This is generated by Riverpod.
  BaseEntityState<T> get state;

  /// Setter for the current state. This is generated by Riverpod.
  set state(BaseEntityState<T> value);

  /// List with Subscriptions
  final List<StreamSubscription> sbs = [];

  /// Behaviorsubject to pause the Entity Stream to avoid mutliple 'data' state
  /// emitions during write operations. This prevents the form to lost track
  /// of the 'touched' state.
  final pauseStream = BehaviorSubject<bool>.seeded(false);

  /// Given an [Either<Failure, T>] object, it updates the state with the Entity
  /// or the Failure.
  void loadStreamIntoState(Either<Failure, T>? failureOrEntity) {
    // If null is received, it is assumed that the Stream is paused
    // and the State should not be modified.
    if (failureOrEntity == null) return;

    final entityInState = state.entity?.copyWith();
    failureOrEntity.fold(
      (failure) => fail(failure),
      (entity) {
        switch (state) {
          // If current state already holds data, update only if the Entity changed.
          case Data(entity: final current, unchanged: _):
            if (entity != current) {
              state = BaseEntityState.data(entity);
            }
            break;

          // For any other state, emit a new data state.
          default:
            state = BaseEntityState.data(
              entity,
              unchanged: entityInState == entity,
            );
        }
      },
    );
  }

  /// Given an Entity, it saves it in the Database. It creates a new Entity if
  /// the Entity's id is '0'. Otherwise, it updates the Entity.
  Future<void> defaultSave(T entity) async {
    pauseStream.add(true);
    final entityInState = state.entity?.copyWith();
    state = BaseEntityState.loading(entityInState);

    /// Wait for a short time to show the loading state.
    await Future.delayed(const Duration(milliseconds: 400));

    /// If id is '0', create Entity. Otherwise, update it.
    if (entity.id == '0') {
      await defaultCreate(entity);
    } else {
      await defaultUpdate(entity);
    }

    pauseStream.add(false);
  }

  /// Creates a new Entity in the Database, via the 'repository'.
  Future<void> defaultCreate(T entity) async {
    if (internetConnection != true) {
      fail(const Failure.network());
      return;
    }

    final createOrFailure = await repository.create(entity);
    createOrFailure.fold(
      (failure) => fail(failure),
      (id) => this.id = id,
    );
  }

  /// Updates an Entity in the Database, via the 'repository'.
  Future<void> defaultUpdate(T entity) async {
    if (internetConnection != true) {
      fail(const Failure.network());
      return;
    }

    final updatedOrFailure = await repository.update(entity.id, entity);
    updatedOrFailure.fold(
      (failure) => fail(failure),
      (_) {},
    );
  }

  /// Given an Entity's [id], deletes an Entity in the Database, via the
  /// 'repository'.
  Future<void> defaultDelete(String id) async {
    if (internetConnection != true) {
      fail(const Failure.network());
      return;
    }

    pauseStream.add(true);
    final entityInState = state.entity?.copyWith();
    state = BaseEntityState.loading(entityInState);

    /// Do not delete an Entity that hasn't been created yet.
    if (id != '0') {
      final deletedOrFailure = await repository.delete(id);
      deletedOrFailure.fold(
        (failure) => fail(failure),
        (r) => state = BaseEntityState.deleted(entityInState),
      );
    }

    // @dev Do not restart the stream, since document is already deleted.
    // pauseStream.add(false);
  }

  /// Given a [Failure] object. If [recordError] is true, logs Failure to console,
  /// and registers error in Crashalytics and updates the state with the Failure.
  void fail(
    Failure failure, {
    recordError = true,
  }) {
    /// Update the state with the Failure.
    final entityInState = state.entity?.copyWith();
    state = BaseEntityState.failure(entityInState, failure);

    if (recordError) {
      /// Lo error into console (only in dev).
      Log.e(
        failure.message,
        exception: failure.cause,
        stackTrace: failure.stackTrace,
      );

      /// Log error into Firebase Crashlytics.
      crashlytics.recordError(
        failure.cause,
        failure.stackTrace,
        fatal: true,
      );
    }
  }

  /// Default method to dispose all subscriptions added to sbs list.
  void defaultDispose() async {
    for (final sb in sbs) {
      await sb.cancel();
    }
    sbs.clear();
  }
}
